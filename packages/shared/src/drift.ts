/**
 * @tminus/shared -- Drift computation for relationship tracking.
 *
 * Pure functions for determining which relationships are overdue for
 * interaction based on their frequency targets and last interaction
 * timestamps.
 *
 * Drift = now - last_interaction_ts > interaction_frequency_target (in days).
 * Urgency is weighted by closeness_weight: higher weight = more urgent.
 */

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/** Minimal relationship shape needed for drift computation. */
export interface DriftInput {
  readonly relationship_id: string;
  readonly participant_hash: string;
  readonly display_name: string | null;
  readonly category: string;
  readonly closeness_weight: number;
  /** ISO 8601 timestamp of last interaction, or null if never interacted. */
  readonly last_interaction_ts: string | null;
  /** Target interaction frequency in days. Null means no target set. */
  readonly interaction_frequency_target: number | null;
}

/** A relationship that is overdue for interaction. */
export interface DriftEntry {
  readonly relationship_id: string;
  readonly participant_hash: string;
  readonly display_name: string | null;
  readonly category: string;
  readonly closeness_weight: number;
  readonly last_interaction_ts: string | null;
  readonly interaction_frequency_target: number;
  /** Days since last interaction (or since epoch if never interacted). */
  readonly days_since_interaction: number;
  /** How many days overdue (days_since_interaction - target). */
  readonly days_overdue: number;
  /** Ratio of days since interaction to frequency target. >1.0 means overdue. */
  readonly drift_ratio: number;
  /** Urgency score: days_overdue * closeness_weight. Higher = more urgent. */
  readonly urgency: number;
}

/**
 * Drift badge severity level for UI display.
 *
 * - "green": on track (drift_ratio <= 1.0)
 * - "yellow": slightly overdue (1.0 < drift_ratio <= 2.0)
 * - "red": significantly overdue (drift_ratio > 2.0)
 * - "none": no frequency target set (not tracked)
 */
export type DriftBadge = "green" | "yellow" | "red" | "none";

/**
 * A persisted drift alert snapshot, generated by daily cron.
 *
 * Note: fields are mutable (not readonly) because this interface is used
 * as a generic parameter for SqlStorageLike.exec<T> which requires
 * T extends Record<string, unknown>.
 */
export interface DriftAlert {
  alert_id: string;
  relationship_id: string;
  display_name: string | null;
  category: string;
  drift_ratio: number;
  days_overdue: number;
  urgency: number;
  computed_at: string;
}

/** Full drift report for a user. */
export interface DriftReport {
  /** Relationships that are overdue, sorted by urgency descending. */
  readonly overdue: DriftEntry[];
  /** Total number of relationships with frequency targets. */
  readonly total_tracked: number;
  /** Number of relationships that are overdue. */
  readonly total_overdue: number;
  /** Timestamp used for computation. */
  readonly computed_at: string;
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

const MS_PER_DAY = 24 * 60 * 60 * 1000;

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Compute drift for a set of relationships at a given point in time.
 *
 * Only relationships with a non-null interaction_frequency_target are
 * considered. Those without a target are excluded from drift tracking.
 *
 * @param relationships - All relationships for the user
 * @param now - Current timestamp (ISO 8601 or Date). Defaults to Date.now().
 * @returns A DriftReport with overdue relationships sorted by urgency.
 */
export function computeDrift(
  relationships: readonly DriftInput[],
  now?: string | Date,
): DriftReport {
  const currentTime = now
    ? typeof now === "string"
      ? new Date(now).getTime()
      : now.getTime()
    : Date.now();

  const computedAt = new Date(currentTime).toISOString();

  // Only track relationships that have a frequency target
  const tracked = relationships.filter(
    (r): r is DriftInput & { interaction_frequency_target: number } =>
      r.interaction_frequency_target !== null &&
      r.interaction_frequency_target > 0,
  );

  const overdue: DriftEntry[] = [];

  for (const rel of tracked) {
    const lastInteraction = rel.last_interaction_ts
      ? new Date(rel.last_interaction_ts).getTime()
      : 0; // epoch if never interacted

    const daysSince = Math.floor(
      (currentTime - lastInteraction) / MS_PER_DAY,
    );
    const daysOverdue = daysSince - rel.interaction_frequency_target;

    const driftRatio = daysSince / rel.interaction_frequency_target;

    if (daysOverdue > 0) {
      overdue.push({
        relationship_id: rel.relationship_id,
        participant_hash: rel.participant_hash,
        display_name: rel.display_name,
        category: rel.category,
        closeness_weight: rel.closeness_weight,
        last_interaction_ts: rel.last_interaction_ts,
        interaction_frequency_target: rel.interaction_frequency_target,
        days_since_interaction: daysSince,
        days_overdue: daysOverdue,
        drift_ratio: Math.round(driftRatio * 100) / 100,
        urgency: daysOverdue * rel.closeness_weight,
      });
    }
  }

  // Sort by urgency descending (most urgent first)
  overdue.sort((a, b) => b.urgency - a.urgency);

  return {
    overdue,
    total_tracked: tracked.length,
    total_overdue: overdue.length,
    computed_at: computedAt,
  };
}

/**
 * Detect which participant hashes from an event match known relationships.
 *
 * Given a set of participant_hashes from a calendar event and a list
 * of relationships, returns the matching relationship IDs.
 *
 * @param eventParticipantHashes - SHA-256 hashes of event attendee emails
 * @param relationships - All relationships with their participant_hashes
 * @returns Array of relationship_ids that match
 */
export function matchEventParticipants(
  eventParticipantHashes: readonly string[],
  relationships: ReadonlyArray<{
    readonly relationship_id: string;
    readonly participant_hash: string;
  }>,
): string[] {
  const hashSet = new Set(eventParticipantHashes);
  return relationships
    .filter((r) => hashSet.has(r.participant_hash))
    .map((r) => r.relationship_id);
}

// ---------------------------------------------------------------------------
// Drift badge computation
// ---------------------------------------------------------------------------

/** Thresholds for drift badge severity. */
const DRIFT_BADGE_YELLOW_THRESHOLD = 1.0;
const DRIFT_BADGE_RED_THRESHOLD = 2.0;

/**
 * Compute the drift badge severity for a single relationship.
 *
 * Given the days since last interaction and the frequency target,
 * returns the appropriate badge level for UI display.
 *
 * @param daysSinceInteraction - Days since last interaction (null if never interacted)
 * @param frequencyTarget - Target frequency in days (null if no target)
 * @returns Badge severity level
 */
export function computeDriftBadge(
  daysSinceInteraction: number | null,
  frequencyTarget: number | null,
): DriftBadge {
  // No frequency target means not tracked
  if (frequencyTarget === null || frequencyTarget <= 0) {
    return "none";
  }

  // If we have no interaction data, treat as maximally overdue
  if (daysSinceInteraction === null) {
    return "red";
  }

  const ratio = daysSinceInteraction / frequencyTarget;

  if (ratio <= DRIFT_BADGE_YELLOW_THRESHOLD) {
    return "green";
  }
  if (ratio <= DRIFT_BADGE_RED_THRESHOLD) {
    return "yellow";
  }
  return "red";
}

/**
 * Compute drift badge from a DriftEntry (convenience wrapper).
 *
 * @param entry - A drift entry from computeDrift results
 * @returns Badge severity level
 */
export function driftEntryBadge(entry: DriftEntry): DriftBadge {
  return computeDriftBadge(
    entry.days_since_interaction,
    entry.interaction_frequency_target,
  );
}
